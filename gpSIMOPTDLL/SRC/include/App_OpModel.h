#ifndef _APPOPTMODEL__HH
#define _APPOPTMODEL__HH

#ifdef GPSIMOPTDLL_EXPORTS
#define GPSIMOPTDLL_API __declspec(dllexport)
#else
#define GPSIMOPTDLL_API __declspec(dllimport)
#endif

//#include "gpProbabilityDLL.h"
//#include "gpSYSDLL.h"
#include "gpBCDLL.h"
#include <ilcplex/ilocplex.h>
#include <time.h>

typedef enum DEOobj
{
ONLYSIMULATION,
ONLYOPTIMIZATION,
SIMOPT,
DOE_SIMOPT,
EXP_SIMOPT,
};
typedef DEOobj TBobj;

typedef enum OPTtype
{
OPTIMIZATION,
EXTENDED_KANBAN,
KANBAN,
BASESTOCK,
SIMULATION,
SIM_EXTENDED_KANBAN,
SIM_KANBAN,
SIM_BASESTOCK,
EXACT_SIM,
EXACT_SIM_KBS,
EXACT_SIM_KCS,
EXACT_SIM_BS,
EXACT_OPT_BSC,
EXACT_OPT_KSC,
EXACT_OPT_EKCS,
EXACT_OPT,
APP_SIM_TBCS,
APP_OPT_TBCS,
};
typedef OPTtype MPROBJ;

typedef enum ALGtype{
PARrep,/*we simply perform multiple replicates*/
INCsp,/*we increase the sample path lenght at each replicate STOP=#replicates*/
INCspwTOL /*increase the sample path length at every step*/
};
typedef ALGtype _myAlgType;
typedef enum MODtype{
REDUCED_OF,/*the constraints are defined over all k(J)=1,...,Km(J) the objective function is defined for k=c[j] on*/
REDUCED_FULL,/*both constraints and obj funct are defined starting from c[j]*/
REDUCED_CONSTR,/*constraints are defined starting form c[j] but the objective function is for all k*/
FULL/*both constraints and objective function start from k=1 (normal version)*/
};
typedef MODtype _myModType;
typedef enum RHS_change{
NOT_CHANGE,
CHANGE_T,
CHANGE_S,/*this will be used during simulation*/
CHANGE_N,//increase the sample path length
};
typedef RHS_change _myRHS_change;
enum SAMPLINGALGO{
MONTECARLO,
LATINHYPERCUBE,
DESCRIPTIVESAMPLING,
};
typedef enum SAMPLINGALGO typeSampling;
namespace OptimizationModel{
ILOSTLBEGIN
 
class GPSIMOPTDLL_API App_OpModel
{	//The types of the parameters and decision variables are defined
	typedef IloArray<IloNumArray> NumMatrix;
	typedef IloArray<IloNumVarArray> NumVarMatrix;
	typedef IloArray<IloIntVarArray> BoolVarMatrix;
	typedef vector<vector<double> > Sol_BAP;//Solution of the buffer allocation problem
	typedef vector<double> Sol_PAP;
	typedef vector<vector<double> > Sol_FT;//Solution in terms of finishing times

	typedef std::vector<int> KM; //represents the matrix containing the maximum capacity
	typedef int PM; //the maximum number of pallets in the system
	typedef double tol; //is the tolerance in case of algtype=2,
	typedef int p0; //initial number of pallets
	typedef std::vector<int> K0; //capacità iniziale dipende
	typedef double step;//is the step if we want to analyze changes in the RHS
	typedef int iterations; //is the number of iterations if we want to analyze changes in the RHS
	typedef std::vector<double> v1;
	typedef std::vector<std::vector<double> > v2;
	

public:
	
	typeSampling mySampleAlgo;
	double alphaLessi;
	MPROBJ _optObj;//simulate or optimize?
	TBobj _deoScope;
	int I;
	productionSystem::gpProductionSystem* _GPmys;
	int d;
	double sr;
	double delta_feasibility;
	double alpha;
	double boundS;
	int contRowFirstTBconst;
	int contRowLastTBconst;
	std::vector<double> ptRHStbCuts;
	std::vector<double> tbRHStbCuts;
	int makeSA;
	int makesimNatwithCosts;
	bool optCUTS;
	bool tbCUTS;
	bool WT_cuts;
	bool SeqModel;
	double boundWTval;
	std::vector<std::vector<double> > TB_bs;
	std::vector<std::vector<int> > IP_bs;
	std::vector<std::vector<int> > IP_ks;
	std::vector<std::vector<double> > TB_kan;
	std::vector<double> cost_stage;
	KM mycap;
	PM myPal;

	//Arrival times can be generated from an input given distribution
	//or can be given as input data the same is for the process times

	std::vector<double> arrivalTimes;
	std::vector<std::vector<double> > processTimes;
	std::vector<double> demandProcess; //time at which the demand for each customer happens

	_myRHS_change _rhsChange;
	_OFtype _myOFtype;
	_myAlgType myAlg;
	tol myTol;
	_myModType mymodType;
	p0 myp0;
	K0 myk0;
	step myStep;
	_myRHS_change myRHS_change;
	iterations myItern;
	int replications;

	//////////////////////////////////////////*
	// CPLEX environment /////////////////////*
	//////////////////////////////////////////*
	IloEnv env;								//*
	IloModel mod;
	IloCplex cplex;							//*
	//////////////////////////////////////////*
	
	//**************************************//
	//   VARIABLES   |**********************//
	//**************************************//
	NumVarMatrix	 y; //finishing times
	NumVarMatrix	 st; //starting times
	NumVarMatrix	 rTime; //release time (for supply chains only)

	NumVarMatrix x_s_b;
	NumVarMatrix x_s_k;
	NumVarMatrix x_ip_s;//blocking mechanism 
	                    //generated by the presence
	                    //of the Inventory position condition
	                    // for controlled systems only
	BoolVarMatrix z_bs;
	BoolVarMatrix z_ks;
	BoolVarMatrix z_buf;
	IloIntVarArray z_pal;
	IloNumVarArray x_s_p;
	IloNumVarArray x_b_p;
	IloNumVar epsilon;

	//**************************************//
	//*********OBJECTIVE FUNCTION***********//
	//**************************************//
	IloNumExpr obj;

	//**************************************//
	//*************CONSTRAINTS**************//
	//**************************************//
	IloRangeArray range;
	//**************************************//
	//*************SOLUTIONS***************//
	//**************************************//
	Sol_BAP bap_soln;
	Sol_PAP pap_soln;
	Sol_FT ft_soln;

	App_OpModel();//default constructor
	App_OpModel(productionSystem::gpProductionSystem* s, double servRate,
		int numParts,int transient,
		std::vector<std::vector<double> > &pt= v2(),
		std::vector<double> &at=v1());
	void SIMOPT(std::map<int,std::vector<std::pair<double,stochasticProperty::gpDistribution*> > > _failDescr,
		std::ofstream & out_file, std::ofstream & f2, std::ofstream & f3, std::ofstream & f4, std::ofstream & f5,
		std::ofstream & out_solApprossimata,std::ifstream & inproc,std::ifstream & inarr, int r=45);
	void SIMonly(std::map<int,std::vector<std::pair<double,stochasticProperty::gpDistribution*> > > _failDescr,
		std::ofstream & out_file, std::ifstream & f2, std::ofstream & f3, std::ofstream & f4, std::ofstream & f5,
		std::ofstream & out_solApprossimata,std::ifstream & inproc,std::ifstream & inarr, int r=45);
	void DEOsimOpt(std::map<int,std::vector<std::pair<double,stochasticProperty::gpDistribution*> > > _failDescr,
		std::ofstream & out_file, std::ofstream & f2, std::ofstream & f3, std::ofstream & f4, std::ofstream & f5,
		std::ofstream & out_solApprossimata,std::ifstream & inproc,std::ifstream & inarr, int r=45);
	void OPTonly(std::map<int,std::vector<std::pair<double,stochasticProperty::gpDistribution*> > > _failDescr,
		std::ofstream & out_file, std::ofstream & f2, std::ofstream & f3, std::ofstream & f4, std::ofstream & f5,
		std::ofstream & out_solApprossimata,std::ifstream & inproc,std::ifstream & inarr, int r=45);
	void computeBounds(std::ofstream & out_f,std::ofstream & out_of);
	void Simulate(std::ofstream & out_file, std::ofstream & f2, std::ofstream & f3, std::ofstream & out_res,int r=1);
	void BuildModel(int numIteration);
	
private:
	bool generateDOEcondition(std::vector<std::vector<double> > & DEOtable);
	void GenProcessTime(std::map<int,std::vector<std::pair<double,stochasticProperty::gpDistribution*> > > _FailureMDescr,
		stochasticProperty::base_generator_type & gen,int iterationIndex,int i);
	void GenArrivals(stochasticProperty::base_generator_type & gen);
	void GenLHSArrivals(stochasticProperty::base_generator_type & gen);
	void GenLHSProcessTime(std::map<int,std::vector<std::pair<double,stochasticProperty::gpDistribution*> > > _FailureMDescr,
		stochasticProperty::base_generator_type & gen,int iterationIndex,int i);
	bool verifySolution(void);
	void BuildTandemLineExactModel(int numIteration);
	void BuildTandemLineApproximateModel(int numIteration);
	void BuildSupplyChainExactModel(int numIteration);
	void BuildSupplyChainApproximateModel(int numIteration);
	void writeOutput(std::ofstream & out_file, std::ofstream & out_TB,std::ofstream & outSumYSumS);
	void writeOutputSimulation(std::ofstream & out_file,std::ofstream & outSumYSumS/*, std::ofstream & f2, std::ofstream & f3*/);
	void writeReplicateResults(std::ofstream & out_rep,int r);
	void Optimize(void);
	void ClearCplexElements(void);
	void createEnvironment(void);
	double computeAvgQueue(std::vector<double> xvec, std::vector<double> yvec,std::vector<double> pt,
		std::vector<int> & zInf,std::vector<double> & SimulatedQueue);
	double computeServiceLevel(std::vector<double> zJ,std::vector<double> DD);
	void AnalyzeQlevel(std::vector<double> xvec, std::vector<double> yvec,std::vector<double> pt,std::vector<int> & zInf,std::vector<std::vector<double> >  & Qlevel);

public:
	~App_OpModel(void);

};

}
#endif